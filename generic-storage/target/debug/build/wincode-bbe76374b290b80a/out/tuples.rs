unsafe impl < Cfg : crate :: config :: Config , A , B > crate :: SchemaWrite < Cfg > for (A , B) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , { type Src = (A :: Src , B :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B > crate :: SchemaRead < 'de , Cfg > for (A , B) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B > { init_count : u8 , dst_ptr : * mut (A , B) , } impl < A , B > Drop for DropGuard < A , B > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C > crate :: SchemaWrite < Cfg > for (A , B , C) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C > crate :: SchemaRead < 'de , Cfg > for (A , B , C) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C > { init_count : u8 , dst_ptr : * mut (A , B , C) , } impl < A , B , C > Drop for DropGuard < A , B , C > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D > crate :: SchemaWrite < Cfg > for (A , B , C , D) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D > { init_count : u8 , dst_ptr : * mut (A , B , C , D) , } impl < A , B , C , D > Drop for DropGuard < A , B , C , D > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E > crate :: SchemaWrite < Cfg > for (A , B , C , D , E) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E) , } impl < A , B , C , D , E > Drop for DropGuard < A , B , C , D , E > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F) , } impl < A , B , C , D , E , F > Drop for DropGuard < A , B , C , D , E , F > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G) , } impl < A , B , C , D , E , F , G > Drop for DropGuard < A , B , C , D , E , F , G > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H) , } impl < A , B , C , D , E , F , G , H > Drop for DropGuard < A , B , C , D , E , F , G , H > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I) , } impl < A , B , C , D , E , F , G , H , I > Drop for DropGuard < A , B , C , D , E , F , G , H , I > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I , J) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , J : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , J :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src , J :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META , < J as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ? + < J as crate :: SchemaWrite < Cfg >> :: size_of (& value . 9) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I , J) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , J : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst , J :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < J as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I , J > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I , J) , } impl < A , B , C , D , E , F , G , H , I , J > Drop for DropGuard < A , B , C , D , E , F , G , H , I , J > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 9u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I , J , K) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , J : crate :: SchemaWrite < Cfg > , K : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , J :: Src : Sized , K :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src , J :: Src , K :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META , < J as crate :: SchemaWrite < Cfg >> :: TYPE_META , < K as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ? + < J as crate :: SchemaWrite < Cfg >> :: size_of (& value . 9) ? + < K as crate :: SchemaWrite < Cfg >> :: size_of (& value . 10) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I , J , K) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , J : crate :: SchemaRead < 'de , Cfg > , K : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst , J :: Dst , K :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < J as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < K as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I , J , K > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I , J , K) , } impl < A , B , C , D , E , F , G , H , I , J , K > Drop for DropGuard < A , B , C , D , E , F , G , H , I , J , K > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 9u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 10u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , J : crate :: SchemaWrite < Cfg > , K : crate :: SchemaWrite < Cfg > , L : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , J :: Src : Sized , K :: Src : Sized , L :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src , J :: Src , K :: Src , L :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META , < J as crate :: SchemaWrite < Cfg >> :: TYPE_META , < K as crate :: SchemaWrite < Cfg >> :: TYPE_META , < L as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ? + < J as crate :: SchemaWrite < Cfg >> :: size_of (& value . 9) ? + < K as crate :: SchemaWrite < Cfg >> :: size_of (& value . 10) ? + < L as crate :: SchemaWrite < Cfg >> :: size_of (& value . 11) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , J : crate :: SchemaRead < 'de , Cfg > , K : crate :: SchemaRead < 'de , Cfg > , L : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst , J :: Dst , K :: Dst , L :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < J as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < K as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < L as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I , J , K , L > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I , J , K , L) , } impl < A , B , C , D , E , F , G , H , I , J , K , L > Drop for DropGuard < A , B , C , D , E , F , G , H , I , J , K , L > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 9u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 10u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 11u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , J : crate :: SchemaWrite < Cfg > , K : crate :: SchemaWrite < Cfg > , L : crate :: SchemaWrite < Cfg > , M : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , J :: Src : Sized , K :: Src : Sized , L :: Src : Sized , M :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src , J :: Src , K :: Src , L :: Src , M :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META , < J as crate :: SchemaWrite < Cfg >> :: TYPE_META , < K as crate :: SchemaWrite < Cfg >> :: TYPE_META , < L as crate :: SchemaWrite < Cfg >> :: TYPE_META , < M as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ? + < J as crate :: SchemaWrite < Cfg >> :: size_of (& value . 9) ? + < K as crate :: SchemaWrite < Cfg >> :: size_of (& value . 10) ? + < L as crate :: SchemaWrite < Cfg >> :: size_of (& value . 11) ? + < M as crate :: SchemaWrite < Cfg >> :: size_of (& value . 12) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , J : crate :: SchemaRead < 'de , Cfg > , K : crate :: SchemaRead < 'de , Cfg > , L : crate :: SchemaRead < 'de , Cfg > , M : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst , J :: Dst , K :: Dst , L :: Dst , M :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < J as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < K as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < L as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < M as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I , J , K , L , M) , } impl < A , B , C , D , E , F , G , H , I , J , K , L , M > Drop for DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 9u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 10u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 11u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 12u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M , N > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M , N) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , J : crate :: SchemaWrite < Cfg > , K : crate :: SchemaWrite < Cfg > , L : crate :: SchemaWrite < Cfg > , M : crate :: SchemaWrite < Cfg > , N : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , J :: Src : Sized , K :: Src : Sized , L :: Src : Sized , M :: Src : Sized , N :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src , J :: Src , K :: Src , L :: Src , M :: Src , N :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. } , TypeMeta :: Static { size : n , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META , < J as crate :: SchemaWrite < Cfg >> :: TYPE_META , < K as crate :: SchemaWrite < Cfg >> :: TYPE_META , < L as crate :: SchemaWrite < Cfg >> :: TYPE_META , < M as crate :: SchemaWrite < Cfg >> :: TYPE_META , < N as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m + n , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ? + < J as crate :: SchemaWrite < Cfg >> :: size_of (& value . 9) ? + < K as crate :: SchemaWrite < Cfg >> :: size_of (& value . 10) ? + < L as crate :: SchemaWrite < Cfg >> :: size_of (& value . 11) ? + < M as crate :: SchemaWrite < Cfg >> :: size_of (& value . 12) ? + < N as crate :: SchemaWrite < Cfg >> :: size_of (& value . 13) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; < N as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 13) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; < N as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 13) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M , N > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M , N) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , J : crate :: SchemaRead < 'de , Cfg > , K : crate :: SchemaRead < 'de , Cfg > , L : crate :: SchemaRead < 'de , Cfg > , M : crate :: SchemaRead < 'de , Cfg > , N : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst , J :: Dst , K :: Dst , L :: Dst , M :: Dst , N :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. } , TypeMeta :: Static { size : n , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < J as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < K as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < L as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < M as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < N as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m + n , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M , N > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I , J , K , L , M , N) , } impl < A , B , C , D , E , F , G , H , I , J , K , L , M , N > Drop for DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M , N > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 9u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 10u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 11u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 12u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 13u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 12) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; * init_count += 1 ; < N as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 13) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; * init_count += 1 ; < N as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 13) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M , N , O > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M , N , O) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , J : crate :: SchemaWrite < Cfg > , K : crate :: SchemaWrite < Cfg > , L : crate :: SchemaWrite < Cfg > , M : crate :: SchemaWrite < Cfg > , N : crate :: SchemaWrite < Cfg > , O : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , J :: Src : Sized , K :: Src : Sized , L :: Src : Sized , M :: Src : Sized , N :: Src : Sized , O :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src , J :: Src , K :: Src , L :: Src , M :: Src , N :: Src , O :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. } , TypeMeta :: Static { size : n , .. } , TypeMeta :: Static { size : o , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META , < J as crate :: SchemaWrite < Cfg >> :: TYPE_META , < K as crate :: SchemaWrite < Cfg >> :: TYPE_META , < L as crate :: SchemaWrite < Cfg >> :: TYPE_META , < M as crate :: SchemaWrite < Cfg >> :: TYPE_META , < N as crate :: SchemaWrite < Cfg >> :: TYPE_META , < O as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m + n + o , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ? + < J as crate :: SchemaWrite < Cfg >> :: size_of (& value . 9) ? + < K as crate :: SchemaWrite < Cfg >> :: size_of (& value . 10) ? + < L as crate :: SchemaWrite < Cfg >> :: size_of (& value . 11) ? + < M as crate :: SchemaWrite < Cfg >> :: size_of (& value . 12) ? + < N as crate :: SchemaWrite < Cfg >> :: size_of (& value . 13) ? + < O as crate :: SchemaWrite < Cfg >> :: size_of (& value . 14) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; < N as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 13) ? ; < O as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 14) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; < N as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 13) ? ; < O as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 14) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M , N , O > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M , N , O) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , J : crate :: SchemaRead < 'de , Cfg > , K : crate :: SchemaRead < 'de , Cfg > , L : crate :: SchemaRead < 'de , Cfg > , M : crate :: SchemaRead < 'de , Cfg > , N : crate :: SchemaRead < 'de , Cfg > , O : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst , J :: Dst , K :: Dst , L :: Dst , M :: Dst , N :: Dst , O :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. } , TypeMeta :: Static { size : n , .. } , TypeMeta :: Static { size : o , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < J as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < K as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < L as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < M as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < N as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < O as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m + n + o , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M , N , O > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I , J , K , L , M , N , O) , } impl < A , B , C , D , E , F , G , H , I , J , K , L , M , N , O > Drop for DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M , N , O > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 9u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 10u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 11u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 12u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 13u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 12) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 14u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 13) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 12) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; * init_count += 1 ; < N as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 13) . cast () }) ? ; * init_count += 1 ; < O as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 14) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; * init_count += 1 ; < N as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 13) . cast () }) ? ; * init_count += 1 ; < O as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 14) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }unsafe impl < Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P > crate :: SchemaWrite < Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P) where A : crate :: SchemaWrite < Cfg > , B : crate :: SchemaWrite < Cfg > , C : crate :: SchemaWrite < Cfg > , D : crate :: SchemaWrite < Cfg > , E : crate :: SchemaWrite < Cfg > , F : crate :: SchemaWrite < Cfg > , G : crate :: SchemaWrite < Cfg > , H : crate :: SchemaWrite < Cfg > , I : crate :: SchemaWrite < Cfg > , J : crate :: SchemaWrite < Cfg > , K : crate :: SchemaWrite < Cfg > , L : crate :: SchemaWrite < Cfg > , M : crate :: SchemaWrite < Cfg > , N : crate :: SchemaWrite < Cfg > , O : crate :: SchemaWrite < Cfg > , P : crate :: SchemaWrite < Cfg > , A :: Src : Sized , B :: Src : Sized , C :: Src : Sized , D :: Src : Sized , E :: Src : Sized , F :: Src : Sized , G :: Src : Sized , H :: Src : Sized , I :: Src : Sized , J :: Src : Sized , K :: Src : Sized , L :: Src : Sized , M :: Src : Sized , N :: Src : Sized , O :: Src : Sized , P :: Src : Sized , { type Src = (A :: Src , B :: Src , C :: Src , D :: Src , E :: Src , F :: Src , G :: Src , H :: Src , I :: Src , J :: Src , K :: Src , L :: Src , M :: Src , N :: Src , O :: Src , P :: Src) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. } , TypeMeta :: Static { size : n , .. } , TypeMeta :: Static { size : o , .. } , TypeMeta :: Static { size : p , .. }) = (< A as crate :: SchemaWrite < Cfg >> :: TYPE_META , < B as crate :: SchemaWrite < Cfg >> :: TYPE_META , < C as crate :: SchemaWrite < Cfg >> :: TYPE_META , < D as crate :: SchemaWrite < Cfg >> :: TYPE_META , < E as crate :: SchemaWrite < Cfg >> :: TYPE_META , < F as crate :: SchemaWrite < Cfg >> :: TYPE_META , < G as crate :: SchemaWrite < Cfg >> :: TYPE_META , < H as crate :: SchemaWrite < Cfg >> :: TYPE_META , < I as crate :: SchemaWrite < Cfg >> :: TYPE_META , < J as crate :: SchemaWrite < Cfg >> :: TYPE_META , < K as crate :: SchemaWrite < Cfg >> :: TYPE_META , < L as crate :: SchemaWrite < Cfg >> :: TYPE_META , < M as crate :: SchemaWrite < Cfg >> :: TYPE_META , < N as crate :: SchemaWrite < Cfg >> :: TYPE_META , < O as crate :: SchemaWrite < Cfg >> :: TYPE_META , < P as crate :: SchemaWrite < Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects)] fn size_of (value : & Self :: Src) -> crate :: WriteResult < usize > { if let TypeMeta :: Static { size , .. } = < Self as crate :: SchemaWrite < Cfg >> :: TYPE_META { Ok (size) } else { Ok (< A as crate :: SchemaWrite < Cfg >> :: size_of (& value . 0) ? + < B as crate :: SchemaWrite < Cfg >> :: size_of (& value . 1) ? + < C as crate :: SchemaWrite < Cfg >> :: size_of (& value . 2) ? + < D as crate :: SchemaWrite < Cfg >> :: size_of (& value . 3) ? + < E as crate :: SchemaWrite < Cfg >> :: size_of (& value . 4) ? + < F as crate :: SchemaWrite < Cfg >> :: size_of (& value . 5) ? + < G as crate :: SchemaWrite < Cfg >> :: size_of (& value . 6) ? + < H as crate :: SchemaWrite < Cfg >> :: size_of (& value . 7) ? + < I as crate :: SchemaWrite < Cfg >> :: size_of (& value . 8) ? + < J as crate :: SchemaWrite < Cfg >> :: size_of (& value . 9) ? + < K as crate :: SchemaWrite < Cfg >> :: size_of (& value . 10) ? + < L as crate :: SchemaWrite < Cfg >> :: size_of (& value . 11) ? + < M as crate :: SchemaWrite < Cfg >> :: size_of (& value . 12) ? + < N as crate :: SchemaWrite < Cfg >> :: size_of (& value . 13) ? + < O as crate :: SchemaWrite < Cfg >> :: size_of (& value . 14) ? + < P as crate :: SchemaWrite < Cfg >> :: size_of (& value . 15) ?) } } # [inline] fn write (mut writer : impl crate :: io :: Writer , value : & Self :: Src) -> crate :: WriteResult < () > { use crate :: io :: Writer ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut writer = unsafe { writer . as_trusted_for (size) } ? ; < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; < N as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 13) ? ; < O as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 14) ? ; < P as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 15) ? ; writer . finish () ? ; } else { < A as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 0) ? ; < B as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 1) ? ; < C as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 2) ? ; < D as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 3) ? ; < E as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 4) ? ; < F as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 5) ? ; < G as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 6) ? ; < H as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 7) ? ; < I as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 8) ? ; < J as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 9) ? ; < K as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 10) ? ; < L as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 11) ? ; < M as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 12) ? ; < N as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 13) ? ; < O as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 14) ? ; < P as crate :: SchemaWrite < Cfg >> :: write (writer . by_ref () , & value . 15) ? ; } Ok (()) } } unsafe impl < 'de , Cfg : crate :: config :: Config , A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P > crate :: SchemaRead < 'de , Cfg > for (A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P) where A : crate :: SchemaRead < 'de , Cfg > , B : crate :: SchemaRead < 'de , Cfg > , C : crate :: SchemaRead < 'de , Cfg > , D : crate :: SchemaRead < 'de , Cfg > , E : crate :: SchemaRead < 'de , Cfg > , F : crate :: SchemaRead < 'de , Cfg > , G : crate :: SchemaRead < 'de , Cfg > , H : crate :: SchemaRead < 'de , Cfg > , I : crate :: SchemaRead < 'de , Cfg > , J : crate :: SchemaRead < 'de , Cfg > , K : crate :: SchemaRead < 'de , Cfg > , L : crate :: SchemaRead < 'de , Cfg > , M : crate :: SchemaRead < 'de , Cfg > , N : crate :: SchemaRead < 'de , Cfg > , O : crate :: SchemaRead < 'de , Cfg > , P : crate :: SchemaRead < 'de , Cfg > , { type Dst = (A :: Dst , B :: Dst , C :: Dst , D :: Dst , E :: Dst , F :: Dst , G :: Dst , H :: Dst , I :: Dst , J :: Dst , K :: Dst , L :: Dst , M :: Dst , N :: Dst , O :: Dst , P :: Dst) ; const TYPE_META : TypeMeta = if let (TypeMeta :: Static { size : a , .. } , TypeMeta :: Static { size : b , .. } , TypeMeta :: Static { size : c , .. } , TypeMeta :: Static { size : d , .. } , TypeMeta :: Static { size : e , .. } , TypeMeta :: Static { size : f , .. } , TypeMeta :: Static { size : g , .. } , TypeMeta :: Static { size : h , .. } , TypeMeta :: Static { size : i , .. } , TypeMeta :: Static { size : j , .. } , TypeMeta :: Static { size : k , .. } , TypeMeta :: Static { size : l , .. } , TypeMeta :: Static { size : m , .. } , TypeMeta :: Static { size : n , .. } , TypeMeta :: Static { size : o , .. } , TypeMeta :: Static { size : p , .. }) = (< A as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < B as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < C as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < D as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < E as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < F as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < G as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < H as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < I as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < J as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < K as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < L as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < M as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < N as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < O as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META , < P as crate :: SchemaRead < 'de , Cfg >> :: TYPE_META) { TypeMeta :: Static { size : a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p , zero_copy : false } } else { TypeMeta :: Dynamic } ; # [inline] # [allow (clippy :: arithmetic_side_effects , clippy :: type_complexity)] fn read (mut reader : impl crate :: io :: Reader < 'de > , dst : & mut core :: mem :: MaybeUninit < Self :: Dst >) -> crate :: ReadResult < () > { use crate :: io :: Reader ; let dst_ptr = dst . as_mut_ptr () ; struct DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P > { init_count : u8 , dst_ptr : * mut (A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P) , } impl < A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P > Drop for DropGuard < A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P > { # [cold] fn drop (& mut self) { let dst_ptr = self . dst_ptr ; match self . init_count { 0u8 => { } , 1u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 2u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 3u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 4u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 5u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 6u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 7u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 8u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 9u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 10u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 11u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 12u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 13u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 12) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 14u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 13) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 12) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , 15u8 => { unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 14) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 13) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 12) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 11) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 10) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 9) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 8) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 7) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 6) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 5) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 4) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 3) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 2) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 1) ; } unsafe { core :: ptr :: drop_in_place (& raw mut (* dst_ptr) . 0) ; } } , _ => { debug_assert ! (false , "init_count out of bounds") ; } , } } } let mut guard = DropGuard { init_count : 0 , dst_ptr } ; let init_count = & mut guard . init_count ; if let TypeMeta :: Static { size , .. } = Self :: TYPE_META { let mut reader = unsafe { reader . as_trusted_for (size) } ? ; < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; * init_count += 1 ; < N as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 13) . cast () }) ? ; * init_count += 1 ; < O as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 14) . cast () }) ? ; * init_count += 1 ; < P as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 15) . cast () }) ? ; } else { < A as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 0) . cast () }) ? ; * init_count += 1 ; < B as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 1) . cast () }) ? ; * init_count += 1 ; < C as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 2) . cast () }) ? ; * init_count += 1 ; < D as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 3) . cast () }) ? ; * init_count += 1 ; < E as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 4) . cast () }) ? ; * init_count += 1 ; < F as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 5) . cast () }) ? ; * init_count += 1 ; < G as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 6) . cast () }) ? ; * init_count += 1 ; < H as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 7) . cast () }) ? ; * init_count += 1 ; < I as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 8) . cast () }) ? ; * init_count += 1 ; < J as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 9) . cast () }) ? ; * init_count += 1 ; < K as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 10) . cast () }) ? ; * init_count += 1 ; < L as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 11) . cast () }) ? ; * init_count += 1 ; < M as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 12) . cast () }) ? ; * init_count += 1 ; < N as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 13) . cast () }) ? ; * init_count += 1 ; < O as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 14) . cast () }) ? ; * init_count += 1 ; < P as crate :: SchemaRead < 'de , Cfg >> :: read (reader . by_ref () , unsafe { & mut * (& raw mut (* dst_ptr) . 15) . cast () }) ? ; } core :: mem :: forget (guard) ; Ok (()) } }